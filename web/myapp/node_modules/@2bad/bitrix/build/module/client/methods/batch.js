import chunk from 'lodash.chunk';
import fromPairs from 'lodash.frompairs';
import { stringify as toQuery } from 'qs';
import { Method } from '../../methods';
import isArray from '../../utils/isArray';
import { handlePayload } from './call';
export const MAX_COMMANDS_PER_BATCH = 50;
export const chunkCommands = (commands, size = MAX_COMMANDS_PER_BATCH) => {
    const commandsIsArray = isArray(commands);
    const chunks = chunk(Object.entries(commands), size);
    return chunks.map((c) => commandsIsArray
        ? c.map(([_key, command]) => command)
        : fromPairs(c));
};
export const prepareCommandsQueries = (commands) => Object.entries(commands).reduce((calls, [name, { method, params }]) => {
    const stringifiedParams = params ? `?${toQuery(params)}` : '';
    return {
        ...calls,
        [`cmd[${name}]`]: `${method}${stringifiedParams}`
    };
}, {});
export const mergeBatchPayloads = (payloads) => {
    const merge = (a, b) => isArray(a) && isArray(b)
        ? [...a, ...b]
        : ({ ...a, ...b });
    return payloads.reduce((merged, payload) => ({
        result: {
            result: merge(merged.result.result || [], payload.result.result),
            result_error: merge(merged.result.result_error || [], payload.result.result_error),
            result_next: merge(merged.result.result_next || [], payload.result.result_next),
            result_time: merge(merged.result.result_time || [], payload.result.result_time),
            result_total: merge(merged.result.result_total || [], payload.result.result_total)
        },
        time: { ...merged.time, ...payload.time }
    }), { result: {}, time: {} });
};
export default ({ get }) => {
    const batch = async (commands, commandsPerRequest = MAX_COMMANDS_PER_BATCH) => {
        const call = (c) => get(Method.BATCH, { query: prepareCommandsQueries(c) })
            .then(({ body }) => body);
        const calls = chunkCommands(commands, commandsPerRequest)
            .map(call);
        return Promise.all(calls)
            .then((chunkedPayloads) => {
            const payloads = mergeBatchPayloads(chunkedPayloads);
            return handlePayload(payloads);
        });
    };
    return batch;
};
//# sourceMappingURL=batch.js.map