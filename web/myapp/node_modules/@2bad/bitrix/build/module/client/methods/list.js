import range from 'lodash.range';
const MAX_ENTRIES_PER_COMMAND = 50;
export const fillWithCommands = ({ method, params }, start, toProcess, entriesPerCommand) => {
    const requiresCommands = Math.ceil((toProcess - start) / entriesPerCommand);
    return range(0, requiresCommands)
        .map((i) => ({ method, params: { ...params, start: start + (entriesPerCommand * i) } }));
};
export const highest = (input) => Object.values(input).reduce((a, b) => a !== undefined && b !== undefined
    ? a > b ? a : b
    : a !== undefined && b === undefined
        ? a
        : a === undefined && b !== undefined
            ? b
            : undefined, undefined);
export const batchToListPayload = (payload) => {
    const { result: { result, result_total, result_error, result_next }, time } = payload;
    const flattenResult = Object.entries(result).reduce((flatten, [_key, r]) => !r ? flatten : [...flatten, ...r], []);
    return {
        error: Object.values(result_error).join('\n'),
        next: highest(result_next),
        result: flattenResult,
        time,
        total: highest(result_total) || 0
    };
};
export default ({ call, batch }) => {
    const list = async (method, params) => {
        const start = params.start || 0;
        const listAll = async () => {
            const batchCommands = fillWithCommands({ method, params }, start, firstCall.total, MAX_ENTRIES_PER_COMMAND);
            const payload = await batch(batchCommands);
            return batchToListPayload(payload);
        };
        const firstCall = await call(method, { ...params, start });
        return !firstCall.next ? firstCall : listAll();
    };
    return list;
};
//# sourceMappingURL=list.js.map