"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_chunk_1 = __importDefault(require("lodash.chunk"));
const lodash_frompairs_1 = __importDefault(require("lodash.frompairs"));
const qs_1 = require("qs");
const methods_1 = require("../../methods");
const isArray_1 = __importDefault(require("../../utils/isArray"));
const call_1 = require("./call");
exports.MAX_COMMANDS_PER_BATCH = 50;
exports.chunkCommands = (commands, size = exports.MAX_COMMANDS_PER_BATCH) => {
    const commandsIsArray = isArray_1.default(commands);
    const chunks = lodash_chunk_1.default(Object.entries(commands), size);
    return chunks.map((c) => commandsIsArray
        ? c.map(([_key, command]) => command)
        : lodash_frompairs_1.default(c));
};
exports.prepareCommandsQueries = (commands) => Object.entries(commands).reduce((calls, [name, { method, params }]) => {
    const stringifiedParams = params ? `?${qs_1.stringify(params)}` : '';
    return Object.assign(Object.assign({}, calls), { [`cmd[${name}]`]: `${method}${stringifiedParams}` });
}, {});
exports.mergeBatchPayloads = (payloads) => {
    const merge = (a, b) => isArray_1.default(a) && isArray_1.default(b)
        ? [...a, ...b]
        : (Object.assign(Object.assign({}, a), b));
    return payloads.reduce((merged, payload) => ({
        result: {
            result: merge(merged.result.result || [], payload.result.result),
            result_error: merge(merged.result.result_error || [], payload.result.result_error),
            result_next: merge(merged.result.result_next || [], payload.result.result_next),
            result_time: merge(merged.result.result_time || [], payload.result.result_time),
            result_total: merge(merged.result.result_total || [], payload.result.result_total)
        },
        time: Object.assign(Object.assign({}, merged.time), payload.time)
    }), { result: {}, time: {} });
};
exports.default = ({ get }) => {
    const batch = async (commands, commandsPerRequest = exports.MAX_COMMANDS_PER_BATCH) => {
        const call = (c) => get(methods_1.Method.BATCH, { query: exports.prepareCommandsQueries(c) })
            .then(({ body }) => body);
        const calls = exports.chunkCommands(commands, commandsPerRequest)
            .map(call);
        return Promise.all(calls)
            .then((chunkedPayloads) => {
            const payloads = exports.mergeBatchPayloads(chunkedPayloads);
            return call_1.handlePayload(payloads);
        });
    };
    return batch;
};
//# sourceMappingURL=batch.js.map